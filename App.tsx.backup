import {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
  type ReactNode,
} from "react";
import "./App.css";
import {
  ScrollText,
  Dices,
  LayoutPanelTop,
  Settings,
  User,
  FilePlus2,
  Puzzle,
  SunMoon,
  Trash2,
  Search,
  FolderPlus,
  X,
  Folder as FolderIcon,
  FileText,
  Pencil,
  ChevronRight,
  ChevronDown,
  FlaskConical,
  PanelLeftClose,
  PanelLeftOpen,
  PanelRightClose,
  PanelRightOpen,
  NotebookPen,
} from "lucide-react";
import { marked } from "marked";
import DevTableForgePane from "./components/DevTableForgePane";

marked.setOptions({
  breaks: true,
});
import { DiceTray } from "./components/DiceTray";
import { ResultsPane } from "./components/ResultsPane";
import type { ResultCardModel } from "./core/results/resultTypes";
import { useUiSettings } from "./contexts/UiSettingsContext";
import {
  fetchAppSettings,
  getDefaultSettings,
  subscribeToSettings,
  updateAppSettings,
  type AppSettings,
} from "./lib/settingsStore";
import DiceExpression, {
  type DiceExpressionWarning,
} from "./lib/dice/DiceExpression";
import DiceRoller, { type RollResult } from "./lib/dice/DiceRoller";
import { annotateRollResult, type RollHighlight } from "./lib/dice/rollHighlights";
import diceBoxValueProvider from "./lib/dice/diceBoxAdapter";
import {
  setDiceFadeDuration,
  setDiceThemeColor,
  setDiceThemeName,
  setDiceScale,
  setDiceTensThemeColor,
  setDiceTexture,
  rollDiceBoxValues,
} from "./core/dice/diceEngine";
import TablesPane from "./components/TablesPane";
import InterpretButton from "./components/InterpretButton";
import { ORACLE_PERSONAS } from './core/ai/oraclePersonas';
import { renderResultCardHtml } from './core/results/ResultCard';

type ActiveTool = "results" | "dice" | "tables" | "diceDev" | "devTools";
type EntryType = "journal" | "note";
type DocKind = "home" | "journal" | "tables" | "tome" | "oracle";

interface DocTab {
  id: string;
  kind: DocKind;
  title: string;
  path?: string;
  isDirty?: boolean;
}

interface Entry {
  id: string;
  title: string;
  type: EntryType;
  content: string;
  updatedAt: number;
  folderId?: string | null;
}

interface TapestryNode {
  type: "folder" | "file";
  name: string;
  path: string;
  children?: TapestryNode[];
  isRoot?: boolean;
}

const containsPath = (node: TapestryNode, target: string): boolean => {
  if (node.path === target) return true;
  if (node.children) {
    return node.children.some((child) => containsPath(child, target));
  }
  return false;
};

const findNodeByName = (nodes: TapestryNode[], name: string): TapestryNode | null => {
  for (const node of nodes) {
    if (node.name === name) return node;
    if (node.children) {
      const found = findNodeByName(node.children, name);
      if (found) return found;
    }
  }
  return null;
};

const getParentFolderPath = (relativePath: string) => {
  if (!relativePath) return "";
  const normalized = relativePath.replace(/\\/g, "/");
  const lastSlash = normalized.lastIndexOf("/");
  return lastSlash >= 0 ? normalized.slice(0, lastSlash) : "";
};

type SettingsCategory =
  | "general"
  | "editor"
  | "files"
  | "diceAppearance"
  | "diceMechanics"
  | "appearance"
  | "hotkeys"
  | "corePlugins"
  | "communityPlugins"
  | "ai";

const settingsNav: { id: SettingsCategory; label: string }[] = [
  { id: "general", label: "General" },
  { id: "editor", label: "Editor" },
  { id: "files", label: "Files & Threads" },
  { id: "diceAppearance", label: "Dice Appearance" },
  { id: "diceMechanics", label: "Dice Mechanics" },
  { id: "appearance", label: "Appearance" },
  { id: "hotkeys", label: "Hotkeys" },
  { id: "corePlugins", label: "Core Plugins" },
  { id: "communityPlugins", label: "Community Plugins" },
  { id: "ai", label: "AI" },
];

const initialEntries: Entry[] = [];

interface PaneState {
  visible: boolean;
  width: number;
}

function App() {
  const { settings: uiSettings, setSettings: setUiSettings } = useUiSettings();
  const [settings, setSettings] = useState<AppSettings>(getDefaultSettings());
  const [settingsLoaded, setSettingsLoaded] = useState(false);
  const [appVersion, setAppVersion] = useState(
    import.meta.env.VITE_APP_VERSION ?? "0.0.0"
  );
  const [tapestryList, setTapestryList] = useState<string[]>([]);
  const [tapestriesLoading, setTapestriesLoading] = useState(false);
  const [newTapestryName, setNewTapestryName] = useState("");
  const [tapestryRootInput, setTapestryRootInput] = useState(
    getDefaultSettings().tapestriesRoot
  );
  const [tapestryTree, setTapestryTree] = useState<TapestryNode[]>([]);
  const [treeLoading, setTreeLoading] = useState(false);
  const [treeError, setTreeError] = useState<string | null>(null);
  const [isSavingEntry, setIsSavingEntry] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  const saveTimerRef = useRef<number | null>(null);
  const [isToolPaneOpen, setToolPaneOpen] = useState(false);
  const [activeTool, setActiveTool] = useState<ActiveTool>("results");
  const [resultCards, setResultCards] = useState<ResultCardModel[]>([]);
  const [leftPane, setLeftPane] = useState<PaneState>({ visible: true, width: 260 });
  const [rightPane, setRightPane] = useState<PaneState>({ visible: false, width: 360 });
  const [entries, setEntries] = useState<Entry[]>(initialEntries);
  const [activeEntryDraftTitle, setActiveEntryDraftTitle] = useState("");
  const [activeEntryDraftContent, setActiveEntryDraftContent] = useState("");
  const [activeEntryId, setActiveEntryId] = useState<string | null>(null);
  const [pendingWelcomeOpen, setPendingWelcomeOpen] = useState<string | null>(null);
  const [selectedFolderPath, setSelectedFolderPath] = useState<string>("");
  const [selectedNode, setSelectedNode] = useState<{
    path: string;
    type: "file" | "folder";
    name: string;
  } | null>(null);
  const [diceDevStatus, setDiceDevStatus] = useState<string | null>(null);
  const [diceDevError, setDiceDevError] = useState<string | null>(null);
  const diceDevAudioPool = useRef<{ surfaces: HTMLAudioElement[]; dice: HTMLAudioElement[] }>({
    surfaces: [],
    dice: [],
  });
  const diceDevAudioPromise = useRef<Promise<void> | null>(null);
  const [entryViewModes, setEntryViewModes] = useState<
    Record<string, "edit" | "view">
  >({});
  const [expandedFolders, setExpandedFolders] = useState<Record<string, boolean>>({ "": true });
  const [renamingPath, setRenamingPath] = useState<string | null>(null);
  const [renamingValue, setRenamingValue] = useState("");
  const [modalState, setModalState] = useState<
    | { type: "create"; target: "entry" | "folder" }
    | { type: "confirmDelete"; node: { path: string; type: "file" | "folder"; name: string } }
    | null
  >(null);
  const [modalValue, setModalValue] = useState("");
  const [searchOpen, setSearchOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [isSettingsOpen, setSettingsOpen] = useState(false);
  const [settingsCategory, setSettingsCategory] =
    useState<SettingsCategory>("general");
  const [sidebarWidth, setSidebarWidth] = useState(260);
  const [toolsWidth, setToolsWidth] = useState(350);
  const [isResizingLeft, setIsResizingLeft] = useState(false);
  const [isResizingRight, setIsResizingRight] = useState(false);
  const [tabs, setTabs] = useState<DocTab[]>([
    { id: "home", kind: "home", title: "Home" },
  ]);
  const [activeTabId, setActiveTabId] = useState<string>("home");
  const activeEntryMode =
    activeEntryId && entryViewModes[activeEntryId]
      ? entryViewModes[activeEntryId]
      : "edit";

  const openTab = useCallback(
    (tab: DocTab) => {
      setTabs((prev) => {
        const exists = prev.some((t) => t.id === tab.id);
        return exists ? prev : [...prev, tab];
      });
      setActiveTabId(tab.id);
      if (tab.kind === "tome") {
        setActiveEntryId(tab.id);
      }
    },
    []
  );


  const closeTab = useCallback(
    (id: string) => {
      setTabs((prev) => {
        const index = prev.findIndex((t) => t.id === id);
        if (index === -1) return prev;
        const nextTabs = [...prev.slice(0, index), ...prev.slice(index + 1)];
        let nextActive: string | null = activeTabId;
        if (id === activeTabId) {
          const candidate = nextTabs[index] ?? nextTabs[index - 1];
          nextActive = candidate ? candidate.id : "home";
        }
        setActiveTabId(nextActive ?? "home");
        if (nextActive) {
          const nextTab = nextTabs.find((t) => t.id === nextActive);
          if (nextTab?.kind === "tome") {
            setActiveEntryId(nextTab.id);
          } else if (nextTab?.kind !== "journal") {
            setActiveEntryId(null);
          }
        } else {
          setActiveEntryId(null);
        }
        return nextTabs.length ? nextTabs : [{ id: "home", kind: "home", title: "Home" }];
      });
    },
    [activeTabId]
  );



  useEffect(() => {
    let isMounted = true;
    fetchAppSettings()
      .then((loaded) => {
        if (!isMounted) return;
        setSettings(loaded);
        setSettingsLoaded(true);
      })
      .catch((error) => {
        console.error("Failed to load settings", error);
        if (isMounted) setSettingsLoaded(true);
      });
    const unsubscribe = subscribeToSettings((next) => {
      setSettings(next);
    });
    return () => {
      isMounted = false;
      unsubscribe?.();
    };
  }, []);

  useEffect(() => {
    document.documentElement.setAttribute("data-theme", settings.theme);
  }, [settings.theme]);

  useEffect(() => {
    if (settings.diceThemeColor) {
      setDiceThemeColor(settings.diceThemeColor);
    }
    if (settings.diceTensThemeColor) {
      setDiceTensThemeColor(settings.diceTensThemeColor);
    }
    if (settings.diceThemeName) {
      setDiceThemeName(settings.diceThemeName);
    }
    if (settings.diceTexture) {
      setDiceTexture(settings.diceTexture);
    }
    if (settings.diceFadeDurationMs) {
      setDiceFadeDuration(settings.diceFadeDurationMs);
    }
    if (settings.diceScale) {
      setDiceScale(settings.diceScale);
    }
  }, [
    settings.diceThemeColor,
    settings.diceTensThemeColor,
    settings.diceThemeName,
    settings.diceTexture,
    settings.diceFadeDurationMs,
    settings.diceScale,
  ]);

  useEffect(() => {
    const handleMove = (event: MouseEvent) => {
      if (isResizingLeft) {
        const next = Math.min(Math.max(event.clientX, 260), 520);
        setSidebarWidth(next);
      } else if (isResizingRight) {
        const total = window.innerWidth;
        const next = Math.min(Math.max(total - event.clientX, 350), 520);
        setToolsWidth(next);
      }
    };
    const stop = () => {
      setIsResizingLeft(false);
      setIsResizingRight(false);
    };
    window.addEventListener("mousemove", handleMove);
    window.addEventListener("mouseup", stop);
    return () => {
      window.removeEventListener("mousemove", handleMove);
      window.removeEventListener("mouseup", stop);
    };
  }, [isResizingLeft, isResizingRight]);

  useEffect(() => {
    setTapestryRootInput(settings.tapestriesRoot);
  }, [settings.tapestriesRoot]);

  useEffect(() => {
    if (!activeEntryId) return;
    setEntryViewModes((prev) =>
      prev[activeEntryId] ? prev : { ...prev, [activeEntryId]: "view" }
    );
  }, [activeEntryId]);

  const fetchTapestryTree = useCallback(() => {
    const api = window.settingsAPI;
    const listFn =
      api?.listTapestryEntries ?? (api as any)?.listTapestriesEntries;
    if (!listFn) {
      setTapestryTree([]);
      setTreeError("Directory view requires the desktop app.");
      return;
    }
    setTreeLoading(true);
    setTreeError(null);
    listFn()
      .then((nodes: TapestryNode[]) => {
        setTapestryTree(nodes);
        setActiveEntryId((previous) => {
          if (!previous) return previous;
          const exists = nodes.some((node) => containsPath(node, previous));
          return exists ? previous : null;
        });
        setSelectedNode((previous) => {
          if (!previous) return previous;
          const exists = nodes.some((node) =>
            containsPath(node, previous.path)
          );
          return exists ? previous : null;
        });
        setSelectedFolderPath((previous) => {
          if (!previous) return "";
          const exists = nodes.some((node) => containsPath(node, previous));
          return exists ? previous : "";
        });
      })
      .catch((error: Error) => {
        console.error("Failed to load Tapestry tree", error);
        setTreeError("Could not read this Tapestry. Check the folder path.");
        setTapestryTree([]);
      })
      .finally(() => setTreeLoading(false));
  }, [settings.currentTapestry, settings.tapestriesRoot]);

  useEffect(() => {
    fetchTapestryTree();
  }, [fetchTapestryTree]);

  useEffect(() => {
    const fallback = import.meta.env.VITE_APP_VERSION ?? "0.0.0";
    if (window.settingsAPI?.getAppVersion) {
      window.settingsAPI
        .getAppVersion()
        .then((version) => {
          setAppVersion(version ?? fallback);
        })
        .catch(() => setAppVersion(fallback));
    } else {
      setAppVersion(fallback);
    }
  }, []);

  useEffect(() => {
    if (!isSettingsOpen) return;
    const handleKey = (event: KeyboardEvent) => {
      if (event.key === "Escape") {
        setSettingsOpen(false);
      }
    };
    window.addEventListener("keydown", handleKey);
    return () => window.removeEventListener("keydown", handleKey);
  }, [isSettingsOpen]);

  const openTool = (tool: ActiveTool) => {
    setActiveTool(tool);
    setToolPaneOpen(true);
    setRightPane(p => ({ ...p, visible: true }));
  };

  const applySettingsPatch = useCallback(
    (partial: Partial<AppSettings>) => {
      updateAppSettings(partial)
        .then((updated) => {
          setSettings(updated);
        })
        .catch((error) => {
          console.error("Failed to update settings", error);
        });
    },
    []
  );

  const refreshTapestries = useCallback(() => {
    if (!settingsLoaded) return;
    setTapestriesLoading(true);
    const api = window.settingsAPI;
    if (api?.listTapestries) {
      api
        .listTapestries()
        .then((list) => setTapestryList(list))
        .catch((error) => {
          console.error("Failed to list tapestries", error);
          setTapestryList([]);
        })
        .finally(() => setTapestriesLoading(false));
    } else {
      setTapestryList(["Prime Chronicle", "Legends of the Vale"]);
      setTapestriesLoading(false);
    }
  }, [settingsLoaded, settings.tapestriesRoot]);

  useEffect(() => {
    refreshTapestries();
  }, [refreshTapestries]);

  useEffect(() => {
    if (tapestryTree.length === 0) {
      setSelectedFolderPath("");
      setSelectedNode(null);
      return;
    }
    const rootNode = tapestryTree[0];
    setSelectedFolderPath((prev) => (prev === "" ? "" : prev));
    if (!selectedNode) {
      setSelectedNode({
        path: rootNode.path,
        type: "folder",
        name: rootNode.name,
      });
    }
  }, [tapestryTree, selectedNode]);

  useEffect(() => {
    setSelectedFolderPath("");
    setSelectedNode(null);
    setActiveEntryId(null);
    setEntries([]);
    setExpandedFolders({ "": true });
    setPendingWelcomeOpen(settings.currentTapestry || null);
  }, [settings.currentTapestry]);

  useEffect(() => {
    if (!selectedNode) {
      setSelectedFolderPath("");
      return;
    }
    const folderPath =
      selectedNode.type === "folder"
        ? selectedNode.path
        : getParentFolderPath(selectedNode.path);
    setSelectedFolderPath(folderPath);
  }, [selectedNode]);

  const handleChooseTapestriesRoot = useCallback(() => {
    const api = window.settingsAPI;
    if (api?.chooseTapestriesRoot) {
      api
        .chooseTapestriesRoot()
        .then((selected) => {
          if (selected) {
            applySettingsPatch({ tapestriesRoot: selected });
            setTapestryRootInput(selected);
          }
        })
        .catch((error) => console.error("Directory picker failed", error));
    } else {
      const trimmed = tapestryRootInput.trim();
      if (!trimmed) {
        window.alert?.("Enter a valid path before applying.");
        return;
      }
      applySettingsPatch({ tapestriesRoot: trimmed });
    }
  }, [applySettingsPatch, settings.tapestriesRoot, tapestryRootInput]);

  const handleSelectTapestry = useCallback(
    (value: string) => {
      applySettingsPatch({ currentTapestry: value });
    },
    [applySettingsPatch]
  );

  const handleCreateTapestry = useCallback(() => {
    const trimmed = newTapestryName.trim();
    if (!trimmed) return;
    const api = window.settingsAPI;
    if (api?.createTapestry) {
      api
        .createTapestry(trimmed)
        .then(() => {
          setNewTapestryName("");
          refreshTapestries();
        })
        .catch((error) => console.error("Failed to create tapestry", error));
    } else {
      setTapestryList((prev) =>
        prev.includes(trimmed) ? prev : [...prev, trimmed]
      );
      applySettingsPatch({ currentTapestry: trimmed });
      setPendingWelcomeOpen(trimmed);
      setNewTapestryName("");
    }
  }, [newTapestryName, applySettingsPatch, refreshTapestries]);


  const handleSelectTreeFile = useCallback(
    (node: TapestryNode) => {
      if (node.type !== "file") return;
      const parentFolder = getParentFolderPath(node.path);
      setSelectedFolderPath(parentFolder);
      setSelectedNode({ path: node.path, type: "file", name: node.name });
      const api = window.settingsAPI;
      if (api?.readTapestryEntry) {
        api
          .readTapestryEntry(node.path)
          .then((result) => {
            const entry: Entry = {
              id: node.path,
              title: node.name,
              type: "note",
              content: result.content ?? "",
              updatedAt: Date.now(),
              folderId: null,
            };
            setEntries((prev) => {
              const remaining = prev.filter((existing) => existing.id !== node.path);
              return [entry, ...remaining];
            });
            setActiveEntryId(node.path);
            openTab({
              id: node.path,
              kind: "tome",
              title: node.name,
              path: node.path,
            });
          })
          .catch((error) =>
            console.error("Failed to read Tapestry entry", error)
          );
      } else {
        const entry: Entry = {
          id: node.path,
          title: node.name,
          type: "note",
          content: "(Preview unavailable outside Electron)",
          updatedAt: Date.now(),
          folderId: null,
        };
        setEntries((prev) => {
          const remaining = prev.filter((existing) => existing.id !== node.path);
          return [entry, ...remaining];
        });
        setActiveEntryId(node.path);
        openTab({
          id: node.path,
          kind: "tome",
          title: node.name,
          path: node.path,
        });
      }
    },
    [openTab]
  );

  const handleSelectTreeFolder = useCallback((node: TapestryNode) => {
    if (node.type !== "folder") return;
    setSelectedFolderPath(node.path);
    setSelectedNode({ path: node.path, type: "folder", name: node.name });
    setExpandedFolders((prev) => ({ ...prev, [node.path]: true }));
  }, []);

  useEffect(() => {
    if (
      !tapestryTree.length ||
      !pendingWelcomeOpen ||
      pendingWelcomeOpen !== settings.currentTapestry
    ) {
      return;
    }
    const welcomeNode = findNodeByName(
      tapestryTree,
      "Welcome to Your Tapestry.md"
    );
    if (!welcomeNode) return;
    setPendingWelcomeOpen(null);
    if (welcomeNode.type === "file") {
      handleSelectTreeFile(welcomeNode);
    } else {
      const childFile = welcomeNode.children?.find(
        (child) => child.type === "file" && child.name === "Welcome to Your Tapestry.md"
      );
      if (childFile) handleSelectTreeFile(childFile);
    }
  }, [
    handleSelectTreeFile,
    pendingWelcomeOpen,
    settings.currentTapestry,
    tapestryTree,
  ]);

  const toggleFolder = useCallback((path: string, isRoot?: boolean) => {
    setExpandedFolders((prev) => {
      const current = prev[path];
      const nextValue =
        typeof current === "boolean" ? !current : !(isRoot ?? false);
      return { ...prev, [path]: nextValue };
    });
  }, []);

  const submitRename = useCallback(
    (node: TapestryNode) => {
      if (!renamingPath) return;
      const trimmed = renamingValue.trim();
      setRenamingPath(null);
      if (!trimmed || trimmed === node.name) {
        setRenamingValue("");
        return;
      }
      const api = window.settingsAPI;
      if (!api?.renameTapestryPath) {
        setRenamingValue("");
        return;
      }
      api
        .renameTapestryPath({ path: node.path, newName: trimmed })
        .then((result) => {
          const newPath = result?.path ?? node.path;
          const updatedNode = { path: newPath, type: node.type, name: trimmed };
          if (selectedNode?.path === node.path) {
            setSelectedNode(updatedNode);
          }
          if (node.type === "file") {
            setEntries((prev) =>
              prev.map((entry) =>
                entry.id === node.path
                  ? { ...entry, id: newPath, title: trimmed }
                  : entry
              )
            );
            setActiveEntryId((prev) => (prev === node.path ? newPath : prev));
          } else if (node.type === "folder") {
            if (selectedFolderPath === node.path) {
              setSelectedFolderPath(newPath);
            }
          }
          fetchTapestryTree();
        })
        .catch((error) => console.error("Rename failed", error))
        .finally(() => setRenamingValue(""));
    },
    [
      fetchTapestryTree,
      renamingPath,
      renamingValue,
      selectedFolderPath,
      selectedNode,
    ]
  );

  const renderTapestryNodes = useCallback(
    (nodes: TapestryNode[], depth = 0): ReactNode[] =>
      nodes.map((node) => {
        const isFolder = node.type === "folder";
        const key = node.path || `${node.name}-${depth}`;
        const nodePath = node.path ?? "";
        const isActive = isFolder
          ? selectedNode?.type === "folder" && selectedNode.path === node.path
          : activeEntryId === node.path;
        const expanded = isFolder
          ? expandedFolders[nodePath] ?? node.isRoot ?? false
          : false;

        return (
          <div key={key} className="tapestry-tree-node">
            <div
              className="tapestry-tree-row-wrapper"
              style={{ paddingLeft: `${depth * 16}px` }}
            >
              {isFolder ? (
                <button
                  type="button"
                  className="tapestry-tree-caret"
                  onClick={(event) => {
                    event.stopPropagation();
                    toggleFolder(nodePath, node.isRoot);
                  }}
                >
                  {expanded ? (
                    <ChevronDown size={14} strokeWidth={2} />
                  ) : (
                    <ChevronRight size={14} strokeWidth={2} />
                  )}
                </button>
              ) : (
                <span className="tapestry-tree-caret tapestry-tree-caret-spacer" />
              )}
              {renamingPath === nodePath ? (
                <input
                  className="tapestry-tree-rename-input"
                  value={renamingValue}
                  autoFocus
                  onChange={(event) => setRenamingValue(event.target.value)}
                  onBlur={() => submitRename(node)}
                  onKeyDown={(event) => {
                    if (event.key === "Enter") {
                      event.preventDefault();
                      submitRename(node);
                    } else if (event.key === "Escape") {
                      setRenamingPath(null);
                      setRenamingValue("");
                    }
                  }}
                />
              ) : (
                <button
                  type="button"
                  className={
                    "tapestry-tree-row" +
                    (isActive ? " tapestry-tree-row-active" : "")
                  }
                  onClick={() =>
                    isFolder
                      ? handleSelectTreeFolder(node)
                      : handleSelectTreeFile(node)
                  }
                  onDoubleClick={(event) => {
                    if (!isFolder) return;
                    event.preventDefault();
                    toggleFolder(nodePath, node.isRoot);
                  }}
                >
                  {isFolder ? (
                    <FolderIcon size={16} strokeWidth={2} />
                  ) : (
                    <FileText size={16} strokeWidth={2} />
                  )}
                  <span>{node.name}</span>
                </button>
              )}
            </div>
            {node.children && node.children.length > 0 && (
              <div
                className="tapestry-tree-children"
                role="group"
                hidden={!expanded}
              >
                {expanded && renderTapestryNodes(node.children, depth + 1)}
              </div>
            )}
          </div>
        );
      }),
    [
      activeEntryId,
      expandedFolders,
      handleSelectTreeFile,
      handleSelectTreeFolder,
      selectedNode,
      toggleFolder,
      renamingPath,
      renamingValue,
    ]
  );

  const visibleTree = useMemo(() => {
    const query = searchQuery.trim().toLowerCase();
    if (!query) return tapestryTree;
    const filterNodes = (nodes: TapestryNode[]): TapestryNode[] => {
      return nodes
        .map((node) => {
          const nameMatches = node.name.toLowerCase().includes(query);
          if (node.type === "file") {
            return nameMatches ? node : null;
          }
          const children = node.children ? filterNodes(node.children) : [];
          if (nameMatches || children.length) {
            return { ...node, children };
          }
          return null;
        })
        .filter(Boolean) as TapestryNode[];
    };
    return filterNodes(tapestryTree);
  }, [searchQuery, tapestryTree]);

  const handleCheckForUpdates = useCallback(() => {
    console.info("Checking for updatesΓÇª");
    window.alert("Checking for updatesΓÇª (coming soon)");
  }, []);

  const handleOpenSettings = () => {
    setSettingsCategory("general");
    setSettingsOpen(true);
  };

  const closeTools = () => {
    setToolPaneOpen(false);
    setRightPane(p => ({ ...p, visible: false }));
  };

  const toggleLeftPane = () => {
    setLeftPane(p => ({ ...p, visible: !p.visible }));
  };

  const toggleRightPane = () => {
    if (rightPane.visible) {
      closeTools();
    } else {
      openTool(activeTool);
    }
  };

  const activeEntry =
    entries.find((entry) => entry.id === activeEntryId) ?? null;
  const renderedMarkdown = useMemo(() => {
    if (!activeEntry) return "";
    return marked.parse(activeEntryDraftContent || "");
  }, [activeEntry, activeEntryDraftContent]);

  useEffect(() => {
    if (activeEntry) {
      setActiveEntryDraftTitle(activeEntry.title);
      setActiveEntryDraftContent(activeEntry.content);
    } else {
      setActiveEntryDraftTitle("");
      setActiveEntryDraftContent("");
    }
  }, [activeEntry]);
  
  const renderMainContent = () => {
  if (!activeEntry) {
      return (
        <div className="app-main-empty">
          <h2>No entry selected</h2>
          <p>Create a new entry to begin weaving this tapestry.</p>
          <button
            className="app-primary-button"
            onClick={() => openCreateModal("entry")}
          >
            + New Entry
          </button>
        </div>
      );
    }

    return (
      <div className="app-editor">
        <div className="app-editor-header">
          <input
            className="app-entry-title-input"
            value={activeEntryDraftTitle}
            onChange={(e) => setActiveEntryDraftTitle(e.target.value)}
            onBlur={commitActiveEntryTitle}
            onKeyDown={(event) => {
              if (event.key === "Enter") {
                event.preventDefault();
                commitActiveEntryTitle();
              } else if (event.key === "Escape") {
                setActiveEntryDraftTitle(activeEntry.title);
              }
            }}
            placeholder="Entry title"
          />
          <div className="app-entry-meta">
            <span>{activeEntry.type}</span>
            <span>
              Updated{" "}
              {new Date(activeEntry.updatedAt).toLocaleTimeString([], {
                hour: "numeric",
                minute: "2-digit",
              })}
            </span>
            <span className="app-entry-save-status">
              {saveError
                ? saveError
                : isSavingEntry
                ? "Saving..."
                : "Saved"}
            </span>
          </div>
          <div className="app-editor-mode-toggle">
            <button
              className={
                "app-editor-mode-button" +
                (activeEntryMode === "edit" ? " app-editor-mode-active" : "")
              }
              onClick={() => setActiveEntryMode("edit")}
            >
              Editor Mode
            </button>
            <button
              className={
                "app-editor-mode-button" +
                (activeEntryMode === "view" ? " app-editor-mode-active" : "")
              }
              onClick={() => setActiveEntryMode("view")}
            >
              View Mode
            </button>
          </div>
          {/* Interpret Oracle Results button */}
          <div style={{ marginLeft: 'auto' }}>
            <InterpretButton
              entryContent={activeEntryDraftContent}
              entryId={activeEntryId}
              onAppend={(html) => {
                // append interpreted HTML to entry content
                if (!activeEntryId) return;
                const baseContent = activeEntryDraftContent.length > 0 ? activeEntryDraftContent : activeEntry?.content ?? "";
                const separator = baseContent.trim().length ? "\n\n" : "";
                const newContent = `${baseContent}${separator}${html}`;
                setActiveEntryDraftContent(newContent);
                setEntries((prev) => prev.map((entry) => entry.id === activeEntryId ? { ...entry, content: newContent, updatedAt: Date.now() } : entry));
                scheduleSave(newContent, activeEntryId);
              }}
              onReplace={(placeholderOrId, replacementHtml) => {
                if (!activeEntryId) return;
                const current = activeEntryDraftContent.length > 0 ? activeEntryDraftContent : activeEntry?.content ?? "";
                let updated = current;

                // Helper to escape for RegExp
                const escapeReg = (s: string) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

                // If the caller passed the whole placeholder HTML, try to extract an id from it
                if (typeof placeholderOrId === 'string' && placeholderOrId.includes('<!--')) {
                  const idMatch = /<!--\s*interpret:start\s+id="([^\"]+)"\s*-->/.exec(placeholderOrId || '');
                  if (idMatch && idMatch[1]) {
                    const id = idMatch[1];
                    const blockRe = new RegExp(`<!--\\s*interpret:start\\s+id=\\"${escapeReg(id)}\\"\\s*-->[\\s\\S]*?<!--\\s*interpret:end\\s+id=\\"${escapeReg(id)}\\"\\s*-->`, 'g');
                    if (blockRe.test(current)) {
                      updated = current.replace(blockRe, replacementHtml);
                    } else if (current.includes(placeholderOrId)) {
                      updated = current.replace(placeholderOrId, replacementHtml);
                    }
                  } else if (current.includes(placeholderOrId)) {
                    updated = current.replace(placeholderOrId, replacementHtml);
                  }
                } else if (typeof placeholderOrId === 'string') {
                  // If placeholderOrId looks like an id (no HTML), replace the marked block by id
                  const id = placeholderOrId;
                  const blockRe = new RegExp(`<!--\\s*interpret:start\\s+id=\\"${escapeReg(id)}\\"\\s*-->[\\s\\S]*?<!--\\s*interpret:end\\s+id=\\"${escapeReg(id)}\\"\\s*-->`, 'g');
                  if (blockRe.test(current)) {
                    updated = current.replace(blockRe, replacementHtml);
                  } else if (current.includes(placeholderOrId)) {
                    updated = current.replace(placeholderOrId, replacementHtml);
                  }
                }

                // Last-resort: append the replacement so nothing is lost
                if (updated === current) {
                  updated = `${current}\n\n${replacementHtml}`;
                }

                console.debug('[App:onReplace] updatedLen', updated.length, 'currentLen', current.length, 'containsReplacement', updated.includes(replacementHtml));

                setActiveEntryDraftContent(updated);
                setEntries((prev) => prev.map((entry) => entry.id === activeEntryId ? { ...entry, content: updated, updatedAt: Date.now() } : entry));
                scheduleSave(updated, activeEntryId);
              }}
              onResultCard={handleAddResultCard}
              getAiSettings={() => {
                const s = settings.ai?.oracle ?? {} as any;
                const personaId = s.oraclePersonaId ?? 'loomwright';
                return {
                  oracleName: s.oracleName ?? 'The Loomwright',
                  oraclePersonaId: personaId,
                  model: s.model ?? 'gpt-5.1-mini',
                  temperature: typeof s.temperature === 'number' ? s.temperature : 0.7,
                  personaAddendum: ORACLE_PERSONAS[personaId]?.systemAddendum ?? '',
                };
              }}
            />
          </div>
        </div>
        {activeEntryMode === "view" ? (
          <div
            className="app-entry-viewer"
            dangerouslySetInnerHTML={{ __html: renderedMarkdown }}
          />
        ) : (
          <textarea
            value={activeEntryDraftContent}
            onChange={(e) => handleEntryContentChange(e.target.value)}
            className="app-editor-textarea"
            placeholder="Start writing your entry..."
          />
        )}
      </div>
    );
  };

  const renderHome = () => (
    <div className="app-main-empty">
      <h2>Welcome to Anvil &amp; Loom</h2>
      <p>Select a file or open a view to begin.</p>
    </div>
  );

  const renderTables = () => (
    <div className="app-main-empty">
      <h2>Tables</h2>
      <p>Oracles / Tables tool will go here.</p>
    </div>
  );

  const renderTomePlaceholder = (tab?: DocTab) => (
    <div className="app-main-empty">
      <h2>{tab?.title ?? "Tome"}</h2>
      <p>Open a Tapestry entry to edit its contents.</p>
    </div>
  );

  const renderTabContent = (tab: DocTab | undefined) => {
    if (!tab) {
      return (
        <div className="app-main-empty">
          <h2>No tabs open</h2>
          <p>Open Home, Journal, or a Tapestry entry to get started.</p>
        </div>
      );
    }
    switch (tab.kind) {
      case "home":
        return renderHome();
      case "journal":
        return renderMainContent();
      case "tables":
        return renderTables();
      case "tome":
        return activeEntry ? renderMainContent() : renderTomePlaceholder(tab);
      case "oracle":
        return (
          <div className="app-main-empty">
            <h2>Oracle</h2>
            <p>Oracle/table editor placeholder.</p>
          </div>
        );
      default:
        return renderHome();
    }
  };

  const renderSettingsContent = () => {
    if (!settingsLoaded) {
      return (
        <section className="settings-section">
          <p className="settings-section-subtitle">Loading settings...</p>
        </section>
      );
    }
    switch (settingsCategory) {
      case "general":
        return (
          <section className="settings-section">
            <h2>General</h2>
            <p className="settings-section-subtitle">
              Core information about Anvil & Loom.
            </p>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Version</p>
                <p className="settings-option-description">
                  You are currently running Anvil & Loom v{appVersion}.
                </p>
              </div>
              <button
                className="app-primary-button settings-check-button"
                onClick={handleCheckForUpdates}
              >
                Check for updates
              </button>
            </div>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Automatic updates</p>
                <p className="settings-option-description">
                  Download stable releases as they become available.
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={settings.automaticUpdates}
                  onChange={(e) =>
                    applySettingsPatch({ automaticUpdates: e.target.checked })
                  }
                />
                <span />
              </label>
            </div>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Developer Mode (show Dev Tools)</p>
                <p className="settings-option-description">
                  Enables in-app development panes like Table Forge.
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={!!(settings as any).developerMode}
                  onChange={(e) => applySettingsPatch({ developerMode: e.target.checked })}
                />
                <span />
              </label>
            </div>
          </section>
        );
      case "editor":
        return (
          <section className="settings-section">
            <h2>Editor</h2>
            <p className="settings-section-subtitle">
              Tune the writing experience for drafting tomes and journal
              entries.
            </p>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Live spellcheck</p>
                <p className="settings-option-description">
                  Highlights typos as you type without changing the parchment
                  aesthetic.
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={settings.liveSpellcheck}
                  onChange={(e) =>
                    applySettingsPatch({ liveSpellcheck: e.target.checked })
                  }
                />
                <span />
              </label>
            </div>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Focus mode</p>
                <p className="settings-option-description">
                  Dim surrounding panes to reduce distractions.
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={settings.focusMode}
                  onChange={(e) =>
                    applySettingsPatch({ focusMode: e.target.checked })
                  }
                />
                <span />
              </label>
            </div>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Default body font</p>
                <p className="settings-option-description">
                  Applied to newly created entries.
                </p>
              </div>
              <select
                className="settings-select"
                value={settings.defaultBodyFont}
                onChange={(e) =>
                  applySettingsPatch({ defaultBodyFont: e.target.value })
                }
              >
                <option value="Caudex">Caudex</option>
                <option value="Inter">Inter</option>
                <option value="Gentium">Gentium</option>
              </select>
            </div>
          </section>
        );
      case "files":
        return (
          <section className="settings-section">
            <h2>Files & Threads</h2>
            <p className="settings-section-subtitle">
              Configure where Anvil & Loom stores Tapestries and all related
              files.
            </p>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">
                  Default location for Tapestries
                </p>
                <p className="settings-option-description">
                  Root directory where all Tapestry folders live.
                </p>
              </div>
              <div className="settings-path-controls">
                <input
                  className="settings-path-input"
                  value={tapestryRootInput}
                  onChange={(e) => setTapestryRootInput(e.target.value)}
                />
                <button
                  className="settings-secondary-button"
                  onClick={handleChooseTapestriesRoot}
                >
                  Choose directory
                </button>
              </div>
            </div>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Current Tapestry</p>
                <p className="settings-option-description">
                  Active project loaded throughout the workspace.
                </p>
              </div>
              {tapestriesLoading ? (
                <p className="settings-hint">Scanning TapestriesΓÇª</p>
              ) : tapestryList.length ? (
                <select
                  className="settings-select"
                  value={settings.currentTapestry}
                  onChange={(e) => handleSelectTapestry(e.target.value)}
                >
                  {tapestryList.map((name) => (
                    <option key={name} value={name}>
                      {name}
                    </option>
                  ))}
                </select>
              ) : (
                <p className="settings-hint">
                  No Tapestries detected. Create one below.
                </p>
              )}
            </div>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Create new Tapestry</p>
                <p className="settings-option-description">
                  Each new Tapestry receives its own assets folder for images
                  and references.
                </p>
              </div>
              <div className="settings-create-row">
                <input
                  type="text"
                  className="settings-text-input"
                  placeholder="Tapestry name"
                  value={newTapestryName}
                  onChange={(e) => setNewTapestryName(e.target.value)}
                />
                <button
                  className="app-primary-button settings-create-button"
                  disabled={!newTapestryName.trim()}
                  onClick={handleCreateTapestry}
                >
                  Create
                </button>
              </div>
            </div>
          </section>
        );
      case "diceAppearance":
        const fadeSeconds = Math.max(
          0.5,
          (settings.diceFadeDurationMs ?? 0) / 1000
        );
        return (
          <section className="settings-section">
            <h2>Dice Appearance</h2>
            <p className="settings-section-subtitle">
              Control how the 3D dice look and linger after each roll.
            </p>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Dice scale</p>
                <p className="settings-option-description">
                  Adjusts the rendered size of dice (1 = smallest, 8 = largest).
                </p>
              </div>
              <div className="settings-fade-control">
                <input
                  type="range"
                  min={1}
                  max={8}
                  step={0.5}
                  value={settings.diceScale ?? 4}
                  onChange={(e) => {
                    const next = Number.parseFloat(e.target.value);
                    const clamped = Number.isFinite(next)
                      ? Math.max(1, Math.min(8, next))
                      : 4;
                    applySettingsPatch({ diceScale: clamped });
                  }}
                />
                <div className="settings-fade-number">
                  <input
                    type="number"
                    min={1}
                    max={8}
                    step={0.5}
                    className="settings-number-input"
                    value={settings.diceScale ?? 4}
                    onChange={(e) => {
                      const next = Number.parseFloat(e.target.value);
                      const clamped = Number.isFinite(next)
                        ? Math.max(1, Math.min(8, next))
                        : 4;
                      applySettingsPatch({ diceScale: clamped });
                    }}
                  />
                </div>
              </div>
            </div>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Fade timer</p>
                <p className="settings-option-description">
                  Seconds before the dice automatically fade off the table.
                </p>
              </div>
              <div className="settings-fade-control">
                <input
                  type="range"
                  min={0.5}
                  max={10}
                  step={0.5}
                  value={fadeSeconds}
                  onChange={(e) => {
                    const nextSeconds = Number.parseFloat(e.target.value);
                    const clamped = Number.isFinite(nextSeconds)
                      ? Math.max(0.5, Math.min(10, nextSeconds))
                      : 0.5;
                    applySettingsPatch({
                      diceFadeDurationMs: Math.round(clamped * 1000),
                    });
                  }}
                />
                <div className="settings-fade-number">
                  <input
                    type="number"
                    min={0.5}
                    max={10}
                    step={0.5}
                    className="settings-number-input"
                    value={fadeSeconds}
                    onChange={(e) => {
                      const nextSeconds = Number.parseFloat(e.target.value);
                      const clamped = Number.isFinite(nextSeconds)
                        ? Math.max(0.5, Math.min(10, nextSeconds))
                        : 0.5;
                      applySettingsPatch({
                        diceFadeDurationMs: Math.round(clamped * 1000),
                      });
                    }}
                  />
                  <span>s</span>
                </div>
              </div>
            </div>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Dice theme</p>
                <p className="settings-option-description">
                  Choose a DiceBox theme (from /assets/themes).
                </p>
              </div>
              <select
                className="settings-select"
                value={settings.diceThemeName ?? "default"}
                onChange={(e) => applySettingsPatch({ diceThemeName: e.target.value })}
              >
                <option value="default">Default</option>
                <option value="rust">Rust</option>
                <option value="diceOfRolling">Dice of Rolling</option>
                <option value="gemstone">Gemstone</option>
              </select>
            </div>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Dice theme color</p>
                <p className="settings-option-description">
                  Sets the base tint used by the dice engine (where supported).
                </p>
              </div>
              <input
                type="color"
                className="settings-color-input"
                value={settings.diceThemeColor ?? "#ff7f00"}
                onChange={(e) =>
                  applySettingsPatch({ diceThemeColor: e.target.value })
                }
              />
            </div>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Tens dice color</p>
                <p className="settings-option-description">
                  Tint for the tens die used in custom percentile rolls (d66/d88).
                </p>
              </div>
              <input
                type="color"
                className="settings-color-input"
                value={settings.diceTensThemeColor ?? "#000000"}
                onChange={(e) =>
                  applySettingsPatch({ diceTensThemeColor: e.target.value })
                }
              />
            </div>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Dice texture</p>
                <p className="settings-option-description">
                  Select a texture from /assets/textures for the dice material.
                </p>
              </div>
              <select
                className="settings-select"
                value={settings.diceTexture ?? "paper"}
                onChange={(e) => applySettingsPatch({ diceTexture: e.target.value })}
              >
                <option value="paper">paper</option>
                <option value="marble">marble</option>
                <option value="metal">metal</option>
                <option value="wood">wood</option>
                <option value="stone">stone</option>
                <option value="ice">ice</option>
                <option value="water">water</option>
                <option value="fire">fire</option>
                <option value="glitter">glitter</option>
                <option value="stars">stars</option>
                <option value="skulls">skulls</option>
                <option value="cheetah">cheetah</option>
                <option value="leopard">leopard</option>
                <option value="tiger">tiger</option>
                <option value="noise">noise</option>
                <option value="astral">astral</option>
              </select>
            </div>
          </section>
        );
      case "diceMechanics":
        return (
          <section className="settings-section">
            <h2>Dice Mechanics</h2>
            <p className="settings-section-subtitle">
              Enable or disable mechanics available in the Dice Tray.
            </p>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Exploding dice</p>
                <p className="settings-option-description">
                  Allow expressions that explode on a trigger (e.g., !6).
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={settings.diceEnableExploding}
                  onChange={(e) =>
                    applySettingsPatch({ diceEnableExploding: e.target.checked })
                  }
                />
                <span />
              </label>
            </div>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Degradation</p>
                <p className="settings-option-description">
                  Allow degrading dice (e.g., !&lt;=2) to step down on triggers.
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={settings.diceEnableDegrade}
                  onChange={(e) =>
                    applySettingsPatch({ diceEnableDegrade: e.target.checked })
                  }
                />
                <span />
              </label>
            </div>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Dice pools</p>
                <p className="settings-option-description">
                  Allow pool-style rolls (success thresholds and targets).
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={settings.diceEnablePools}
                  onChange={(e) =>
                    applySettingsPatch({ diceEnablePools: e.target.checked })
                  }
                />
                <span />
              </label>
            </div>
          </section>
        );
      case "diceThemes":
        return (
          <section className="settings-section">
            <h2>Dice Theme & Tens</h2>
            <p className="settings-section-subtitle">
              Choose the DiceBox theme and the colors used for primary and tens dice (d66/d88).
            </p>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Dice theme</p>
                <p className="settings-option-description">
                  Applies a preset dice style from the available DiceBox themes.
                </p>
              </div>
              <select
                className="settings-select"
                value={settings.diceThemeName ?? "default"}
                onChange={(e) => applySettingsPatch({ diceThemeName: e.target.value })}
              >
                <option value="default">Default</option>
                <option value="rust">Rust</option>
                <option value="diceOfRolling">Dice of Rolling</option>
                <option value="gemstone">Gemstone</option>
              </select>
            </div>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Primary dice color</p>
                <p className="settings-option-description">
                  Base tint for all dice (where supported by the theme).
                </p>
              </div>
              <input
                type="color"
                className="settings-color-input"
                value={settings.diceThemeColor ?? "#ff7f00"}
                onChange={(e) => applySettingsPatch({ diceThemeColor: e.target.value })}
              />
            </div>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Tens dice color</p>
                <p className="settings-option-description">
                  Tint for the tens die used in custom percentile rolls (d66/d88).
                </p>
              </div>
              <input
                type="color"
                className="settings-color-input"
                value={settings.diceTensThemeColor ?? "#000000"}
                onChange={(e) => applySettingsPatch({ diceTensThemeColor: e.target.value })}
              />
            </div>
          </section>
        );
      case "appearance":
        return (
          <section className="settings-section">
            <h2>Appearance</h2>
            <p className="settings-section-subtitle">
              Customize themes, typography, and contrast modes.
            </p>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Accent color</p>
                <p className="settings-option-description">
                  Sets the highlight for icons, cursors, and buttons.
                </p>
              </div>
              <select
                className="settings-select"
                value={settings.accentColor}
                onChange={(e) =>
                  applySettingsPatch({ accentColor: e.target.value })
                }
              >
                <option value="Gilded Ember">Gilded Ember</option>
                <option value="Arcane Azure">Arcane Azure</option>
                <option value="Verdant Noir">Verdant Noir</option>
              </select>
            </div>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">High contrast text</p>
                <p className="settings-option-description">
                  Improve legibility for bright environments.
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={settings.highContrastText}
                  onChange={(e) =>
                    applySettingsPatch({ highContrastText: e.target.checked })
                  }
                />
                <span />
              </label>
            </div>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Show parchment texture</p>
                <p className="settings-option-description">
                  Adds subtle grain behind entry content.
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={settings.showParchmentTexture}
                  onChange={(e) =>
                    applySettingsPatch({ showParchmentTexture: e.target.checked })
                  }
                />
                <span />
              </label>
            </div>
          </section>
        );
      case "hotkeys":
        return (
          <section className="settings-section">
            <h2>Hotkeys</h2>
            <p className="settings-section-subtitle">
              Reference or customize keyboard shortcuts.
            </p>
            <div className="hotkey-grid">
              <div className="hotkey-row">
                <span className="hotkey-label">New entry</span>
                <span className="hotkey-value">Ctrl/Cmd + N</span>
              </div>
              <div className="hotkey-row">
                <span className="hotkey-label">Duplicate entry</span>
                <span className="hotkey-value">Ctrl/Cmd + D</span>
              </div>
              <div className="hotkey-row">
                <span className="hotkey-label">Toggle Dice Tray</span>
                <span className="hotkey-value">Ctrl/Cmd + Shift + T</span>
              </div>
              <div className="hotkey-row">
                <span className="hotkey-label">Search</span>
                <span className="hotkey-value">Ctrl/Cmd + K</span>
              </div>
            </div>
          </section>
        );
      case "corePlugins":
        return (
          <section className="settings-section">
            <h2>Core Plugins</h2>
            <p className="settings-section-subtitle">
              Built-in capabilities maintained by Anvil & Loom.
            </p>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Dice Engine</p>
                <p className="settings-option-description">
                  Enables all dice tray interactions and result history.
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={settings.coreDiceEngine}
                  onChange={(e) =>
                    applySettingsPatch({ coreDiceEngine: e.target.checked })
                  }
                />
                <span />
              </label>
            </div>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Tapestry Sync</p>
                <p className="settings-option-description">
                  Keeps entries mirrored to disk under /tapestries.
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={settings.coreTapestrySync}
                  onChange={(e) =>
                    applySettingsPatch({ coreTapestrySync: e.target.checked })
                  }
                />
                <span />
              </label>
            </div>
            <div className="settings-option">
              <div>
                <p className="settings-option-label">Lore Atlas</p>
                <p className="settings-option-description">
                  Visualize entry relationships on an interactive map.
                </p>
              </div>
              <label className="settings-toggle">
                <input
                  type="checkbox"
                  checked={settings.coreLoreAtlas}
                  onChange={(e) =>
                    applySettingsPatch({ coreLoreAtlas: e.target.checked })
                  }
                />
                <span />
              </label>
            </div>
          </section>
        );
      case "communityPlugins":
        return (
          <section className="settings-section">
            <h2>Community Plugins</h2>
            <p className="settings-section-subtitle">
              Install experimental add-ons crafted by fellow storytellers.
            </p>
            <div className="community-callout">
              Browse the curated catalog once you connect your creator profile.
            </div>
            <button className="app-primary-button">Open plugin browser</button>
          </section>
        );
      case "ai":
        return (
          <section className="settings-section">
            <h2>AI</h2>
            <p className="settings-section-subtitle">Configure OpenAI and Oracle settings used by Dev Tools.</p>

            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">OpenAI API Key</p>
                <p className="settings-option-description">Stored locally (desktop) or provided server-side (web). Never commit your key.</p>
              </div>
              <input
                type="password"
                className="settings-text-input"
                placeholder="sk-..."
                value={(settings as any).openaiApiKey ?? ""}
                onChange={(e) => applySettingsPatch({ openaiApiKey: e.target.value })}
              />
            </div>

            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">OpenAI Model</p>
                <p className="settings-option-description">E.g., gpt-5.1-mini (desktop/web can differ).</p>
              </div>
              <input
                type="text"
                className="settings-text-input"
                placeholder="gpt-5.1-mini"
                value={(settings.ai?.oracle?.model) ?? "gpt-5.1-mini"}
                onChange={(e) => applySettingsPatch({ ai: { ...(settings.ai ?? {}), oracle: { ...(settings.ai?.oracle ?? {}), model: e.target.value } } })}
              />
            </div>

            <hr />
            <h3>Oracle</h3>
            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Oracle Name</p>
                <p className="settings-option-description">Friendly name shown in the Interpret button and card headers.</p>
              </div>
              <input
                type="text"
                className="settings-text-input"
                placeholder="The Loomwright"
                value={(settings.ai?.oracle?.oracleName) ?? "The Loomwright"}
                onChange={(e) => applySettingsPatch({ ai: { ...(settings.ai ?? {}), oracle: { ...(settings.ai?.oracle ?? {}), oracleName: e.target.value } } })}
              />
            </div>

            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Oracle Persona</p>
                <p className="settings-option-description">Choose how the oracle will interpret results.</p>
              </div>
                                                                                    <select
                className="settings-select"
                value={(settings.ai?.oracle?.oraclePersonaId) ?? 'loomwright'}
                onChange={(e) => {
                  const personaId = e.target.value as any;
                  const newLabel = ORACLE_PERSONAS[personaId]?.label ?? '';
                  applySettingsPatch({ ai: { ...(settings.ai ?? {}), oracle: { ...(settings.ai?.oracle ?? {}), oraclePersonaId: personaId, oracleName: newLabel } } });
                }}
              >
                {Object.values(ORACLE_PERSONAS).map((p) => (
                  <option key={p.id} value={p.id}>{p.label}</option>
                ))}
              </select>
              <p className="settings-option-description" style={{ marginTop: '0.5rem' }}>{ORACLE_PERSONAS[(settings.ai?.oracle?.oraclePersonaId) ?? 'loomwright']?.description}</p>
            </div>

            <div className="settings-option settings-option-column">
              <div>
                <p className="settings-option-label">Oracle temperature</p>
                <p className="settings-option-description">Creativity / randomness for the oracle output (0.0-1.2).</p>
              </div>
              <input
                type="number"
                min={0}
                max={1.2}
                step={0.05}
                className="settings-number-input"
                value={(settings.ai?.oracle?.temperature) ?? 0.7}
                onChange={(e) => applySettingsPatch({ ai: { ...(settings.ai ?? {}), oracle: { ...(settings.ai?.oracle ?? {}), temperature: Number.parseFloat(e.target.value) } } })}
              />
            </div>

          </section>
        );
      default:
        return (
          <section className="settings-section">
            <h2>Community Plugins</h2>
            <p className="settings-section-subtitle">
              Install experimental add-ons crafted by fellow storytellers.
            </p>
            <div className="community-callout">
              Browse the curated catalog once you connect your creator profile.
            </div>
            <button className="app-primary-button">Open plugin browser</button>
          </section>
        );
    }
  };

  const toggleTheme = () => {
    const next = settings.theme === "dark" ? "light" : "dark";
    applySettingsPatch({ theme: next });
  };

  const createFolder = useCallback(
    (folderName: string) => {
      const api = window.settingsAPI;
      if (!api?.createTapestryFolder) {
        window.alert?.("Folder creation requires the desktop app.");
        return Promise.reject(new Error("Desktop API unavailable"));
      }
      const parentPath = selectedFolderPath ?? "";
      return api
        .createTapestryFolder({
          parentPath,
          folderName,
        })
        .then((result) => {
          const createdPath = result?.path ?? "";
          const createdName = result?.name ?? folderName;
          setSelectedNode({
            path: createdPath,
            type: "folder",
            name: createdName,
          });
          setExpandedFolders((prev) => ({
            ...prev,
            [parentPath]: true,
            [createdPath]: true,
          }));
          fetchTapestryTree();
        });
    },
    [fetchTapestryTree, selectedFolderPath]
  );

  const createEntry = useCallback(
    (entryName: string) => {
      const api = window.settingsAPI;
      if (!api?.createTapestryEntry) {
        window.alert?.("Entry creation requires the desktop app.");
        return Promise.reject(new Error("Desktop API unavailable"));
      }
      const parentPath = selectedFolderPath ?? "";
      return api
        .createTapestryEntry({
          parentPath,
          entryName,
        })
        .then((result) => {
          fetchTapestryTree();
          if (result?.path) {
            handleSelectTreeFile({
              type: "file",
              name: result?.name ?? entryName,
              path: result.path,
            });
          }
        });
    },
    [fetchTapestryTree, handleSelectTreeFile, selectedFolderPath]
  );

  const handleRenameSelected = useCallback(() => {
    if (
      !selectedNode ||
      (selectedNode.type === "folder" && selectedNode.path === "")
    ) {
      return;
    }
    setRenamingPath(selectedNode.path);
    setRenamingValue(selectedNode.name);
  }, [selectedNode]);

  const handleDeleteSelected = useCallback(() => {
    if (
      !selectedNode ||
      (selectedNode.type === "folder" && selectedNode.path === "")
    ) {
      return;
    }
    setModalState({ type: "confirmDelete", node: selectedNode });
  }, [selectedNode]);

  const performDelete = useCallback(
    (node: { path: string; type: "file" | "folder"; name: string }) => {
      const api = window.settingsAPI;
      if (!api?.deleteTapestryPath) {
        return Promise.reject(new Error("Deletion requires the desktop app."));
      }
      return api
        .deleteTapestryPath({ path: node.path })
        .then(() => {
        if (node.type === "file") {
          setEntries((prev) => prev.filter((entry) => entry.id !== node.path));
          setActiveEntryId((prev) => (prev === node.path ? null : prev));
        }
        const parent = getParentFolderPath(node.path);
        setSelectedFolderPath(parent);
        setSelectedNode(null);
        fetchTapestryTree();
      });
    },
    [fetchTapestryTree]
  );

  const openCreateModal = useCallback(
    (target: "entry" | "folder") => {
      setModalState({ type: "create", target });
      setModalValue("");
    },
    []
  );

  const setActiveEntryMode = useCallback(
    (mode: "edit" | "view") => {
      if (!activeEntryId) return;
      setEntryViewModes((prev) => ({ ...prev, [activeEntryId]: mode }));
    },
    [activeEntryId]
  );

  const closeModal = useCallback(() => {
    setModalState(null);
    setModalValue("");
  }, []);

  const handleModalConfirm = useCallback(() => {
    if (!modalState) return;
    if (modalState.type === "create") {
      const value = modalValue.trim();
      if (!value) return;
      const action =
        modalState.target === "folder"
          ? createFolder(value)
          : createEntry(value);
      action
        .then(() => closeModal())
        .catch(() => closeModal());
    } else if (modalState.type === "confirmDelete") {
      performDelete(modalState.node)
        .then(() => closeModal())
        .catch(() => closeModal());
    }
  }, [closeModal, createEntry, createFolder, modalState, modalValue, performDelete]);

  const scheduleSave = useCallback(
    (content: string, entryId: string) => {
      if (!window.settingsAPI?.saveTapestryEntry) return;
      if (saveTimerRef.current) {
        window.clearTimeout(saveTimerRef.current);
      }
      saveTimerRef.current = window.setTimeout(() => {
        setIsSavingEntry(true);
        setSaveError(null);
        window.settingsAPI
          ?.saveTapestryEntry({ path: entryId, content })
          .then(() => {
            setIsSavingEntry(false);
          })
          .catch((error) => {
            console.error("Failed to save entry", error);
            setIsSavingEntry(false);
            setSaveError("Failed to save entry");
          });
      }, 700);
    },
    []
  );

  const handleDiceRollLog = useCallback(
    (markdown: string) => {
      if (!activeEntryId) return;
      const baseContent =
        activeEntryDraftContent.length > 0
          ? activeEntryDraftContent
          : activeEntry?.content ?? "";
      const separator = baseContent.trim().length ? "\n\n" : "";
      const newContent = `${baseContent}${separator}${markdown}`;
      setActiveEntryDraftContent(newContent);
      setEntries((prev) =>
        prev.map((entry) =>
          entry.id === activeEntryId
            ? { ...entry, content: newContent, updatedAt: Date.now() }
            : entry
        )
      );
      scheduleSave(newContent, activeEntryId);
    },
    [activeEntry, activeEntryDraftContent, activeEntryId, scheduleSave]
  );

  const handleAddResultCard = useCallback((card: ResultCardModel) => {
    setResultCards((prev) => [...prev, card]);
  }, []);

  const handleClearResults = useCallback(() => {
    setResultCards([]);
  }, []);

  const handleEntryContentChange = useCallback(
    (nextValue: string) => {
      if (!activeEntryId) return;
      setEntries((prev) =>
        prev.map((entry) =>
          entry.id === activeEntryId
            ? { ...entry, content: nextValue, updatedAt: Date.now() }
            : entry
        )
      );
      setActiveEntryDraftContent(nextValue);
      scheduleSave(nextValue, activeEntryId);
    },
    [activeEntryId, scheduleSave]
  );

  const commitActiveEntryTitle = useCallback(() => {
    if (!activeEntry) return;
    const trimmed = activeEntryDraftTitle.trim();
    if (!trimmed || trimmed === activeEntry.title) {
      setActiveEntryDraftTitle(activeEntry.title);
      return;
    }
    const api = window.settingsAPI;
    if (!api?.renameTapestryPath) {
      setActiveEntryDraftTitle(activeEntry.title);
      return;
    }
    api
      .renameTapestryPath({ path: activeEntry.id, newName: trimmed })
      .then((result) => {
        const newPath = result?.path ?? activeEntry.id;
        setEntries((prev) =>
          prev.map((entry) =>
            entry.id === activeEntry.id
              ? { ...entry, id: newPath, title: trimmed }
              : entry
          )
        );
        setActiveEntryId(newPath);
        setSelectedNode({ path: newPath, type: "file", name: trimmed });
        fetchTapestryTree();
      })
      .catch((error) => {
        console.error("Failed to rename entry", error);
        setActiveEntryDraftTitle(activeEntry.title);
      });
  }, [activeEntry, activeEntryDraftTitle, fetchTapestryTree]);

  const loadDiceDevAudio = useCallback(async () => {
    if (diceDevAudioPromise.current) {
      return diceDevAudioPromise.current;
    }
    diceDevAudioPromise.current = (async () => {
      const loadClip = async (src: string) => {
        return new Promise<HTMLAudioElement>((resolve, reject) => {
          const audio = new Audio();
          audio.oncanplaythrough = () => resolve(audio);
          audio.onerror = (e) => reject(e);
          audio.crossOrigin = "anonymous";
          audio.src = src;
        });
      };

      const surfaces: HTMLAudioElement[] = [];
      const dice: HTMLAudioElement[] = [];
      // Wood table surface (1-7)
      for (let i = 1; i <= 7; i++) {
        try {
          surfaces.push(await loadClip(`/assets/sounds/surfaces/surface_wood_table${i}.mp3`));
        } catch {
          /* ignore */
        }
      }
      // Plastic dice hits (1-15)
      for (let i = 1; i <= 15; i++) {
        try {
          dice.push(await loadClip(`/assets/sounds/dicehit/dicehit_plastic${i}.mp3`));
        } catch {
          /* ignore */
        }
      }
      diceDevAudioPool.current = { surfaces, dice };
    })();
    return diceDevAudioPromise.current;
  }, []);

const maybePlayDiceDevAudio = useCallback(async () => {
  try {
    await loadDiceDevAudio();
    const { surfaces, dice } = diceDevAudioPool.current;
    if (!surfaces.length && !dice.length) return;
      const playClip = (clip?: HTMLAudioElement) => {
        if (!clip) return;
        clip.currentTime = 0;
        clip.play().catch(() => {});
      };
      const hits = Math.max(1, Math.floor(Math.random() * 2) + 2); // 2-3 hits
      for (let i = 0; i < hits; i++) {
        const delay = 75 + Math.random() * 375; // concentrate near start
        setTimeout(() => {
          playClip(surfaces[Math.floor(Math.random() * surfaces.length)]);
          playClip(dice[Math.floor(Math.random() * dice.length)]);
        }, delay);
    }
  } catch {
    // ignore audio failures so rolls don't break
  }
}, [loadDiceDevAudio]);

  const handleDiceDevBoxRoll = useCallback(async () => {
    try {
      void maybePlayDiceDevAudio();
      const values = await rollDiceBoxValues(2, 20);
      setDiceDevStatus("Rolled 2d20 via DiceBox (see overlay)");
      setDiceDevError(null);
    } catch (error) {
      console.error("DiceBox test roll failed", error);
      setDiceDevStatus(null);
      setDiceDevError(error instanceof Error ? error.message : "Test roll failed");
    }
  }, [
    maybePlayDiceDevAudio,
  ]);

  const renderDiceDevPanel = () => (
    <div className="dice-dev-panel">
      <div className="dice-dev-controls" style={{ marginBottom: "1rem" }}>
        <label>DiceBox Test (assetPath /assets/dice-box)</label>
        <div style={{ display: "flex", gap: "0.5rem", flexWrap: "wrap", alignItems: "center" }}>
          <button type="button" onClick={handleDiceDevBoxRoll}>
            Roll 2d20
          </button>
        </div>
        {diceDevStatus && <div className="dice-dev-status">{diceDevStatus}</div>}
        {diceDevError && <div className="dice-dev-error">{diceDevError}</div>}
      </div>
    </div>
  );

  const renderToolContent = () => (
    <div className="app-tools-content">
      {activeTool === "results" && (
        <ResultsPane
          results={resultCards}
          onClearResults={handleClearResults}
        />
      )}

      {activeTool === "tables" && (
        <TablesPane
          activeEntryId={activeEntryId}
                      onOracleResult={(payload) => {
            // Append an Oracle-style Result Card to the active entry (tables only) using canonical renderer
            if (!activeEntryId) return;
            const baseContent =
              activeEntryDraftContent.length > 0
                ? activeEntryDraftContent
                : activeEntry?.content ?? "";
            const separator = baseContent.trim().length ? "\n\n" : "";
            const card = {
              id: `card-${Date.now()}-${Math.random().toString(36).slice(2,11)}`,
              kind: "table",
              createdAt: Date.now(),
              tableId: payload.tableId,
              tableName: payload.tableName,
              roll: payload.roll,
              resultText: payload.resultText,
              headerText: `TABLE: ${payload.tableName.toUpperCase()}`,
              contentText: `Roll: ${payload.roll}`,
              theme: "table",
              sourcePath: payload.sourcePath,
            } as any;
                        // Use renderer to produce HTML identical to Results Pane
            const html = renderResultCardHtml(card);
            const meta = `<!-- forge:oracle tableId="${payload.tableId}" sourcePath="${payload.sourcePath}" roll=${payload.roll} result="${payload.resultText?.replace(/"/g,'\"')}" tags='${JSON.stringify(payload.tags || [])}' category="${payload.category || ""}" -->`;
            const newContent = `${baseContent}${separator}${html}${meta}`;
            setActiveEntryDraftContent(newContent);
            setEntries((prev) =>
              prev.map((entry) =>
                entry.id === activeEntryId
                  ? { ...entry, content: newContent, updatedAt: Date.now() }
                  : entry
              )
            );
            scheduleSave(newContent, activeEntryId);
          }}
          onResultCard={handleAddResultCard}
          onOpenTableEditor={(tableId) => {
            console.log("Open table editor for", tableId);
            // TODO: create a Tab kind for Table Editor and open it here
          }}
        />
      )}

      {activeTool === "diceDev" && renderDiceDevPanel()}

      {activeTool === "devTools" && settings.developerMode && (
        <div style={{ padding: "0.5rem" }}>
          <DevTableForgePane />
        </div>
      )}

      {/* DiceTray stays mounted, just hidden when not active */}
        <div style={{ display: activeTool === "dice" ? "block" : "none" }}>
          <DiceTray
            onRollResult={handleDiceRollLog}
            onResultCard={handleAddResultCard}
            fadeDurationMs={settings.diceFadeDurationMs}
          />
        </div>
      </div>
    );

  const statusText = "Connected to local workspace";

  const gridTemplateColumns = `
    ${leftPane.visible ? `${leftPane.width}px` : "0px"}
    ${leftPane.visible ? "10px" : "0px"}
    1fr
    ${isToolPaneOpen ? "10px" : "0px"}
    ${isToolPaneOpen ? `${toolsWidth}px` : "0px"}
  `.trim();

  return (
    <div className="app-root">
      <div className="app-shell" style={{ gridTemplateColumns }}>
      {/* LEFT: Tome / library pane */}
      <aside className="app-sidebar" style={{ width: leftPane.visible ? leftPane.width : 0, display: leftPane.visible ? "flex" : "none" }}>
        <div className="app-sidebar-header">
          <div className="app-logo-mark" />
          <div className="app-logo-text">
            <div className="app-logo-title">Anvil &amp; Loom</div>
            <div className="app-logo-subtitle">TOME</div>
          </div>
          <button
            className="pane-collapse-button"
            onClick={toggleLeftPane}
            aria-label="Collapse sidebar"
            title="Collapse sidebar"
          >
            <PanelLeftClose size={18} strokeWidth={2} />
          </button>
        </div>

        <div className="app-sidebar-toolbar">
          <button
            className="sidebar-toolbar-button icon-button"
            aria-label="New entry"
            data-tooltip="New entry"
            onClick={() => openCreateModal("entry")}
          >
            <FilePlus2 size={20} strokeWidth={2} />
          </button>
          <button
            className="sidebar-toolbar-button icon-button"
            aria-label="New folder"
            data-tooltip="New folder"
            onClick={() => openCreateModal("folder")}
          >
            <FolderPlus size={20} strokeWidth={2} />
          </button>
          <button
            className="sidebar-toolbar-button icon-button"
            aria-label="Rename"
            data-tooltip="Rename"
            onClick={handleRenameSelected}
            disabled={
              !selectedNode ||
              (selectedNode.type === "folder" && selectedNode.path === "")
            }
          >
            <Pencil size={20} strokeWidth={2} />
          </button>
          <button
            className="sidebar-toolbar-button icon-button"
            aria-label="Delete entry"
            data-tooltip="Delete entry"
            onClick={handleDeleteSelected}
            disabled={
              !selectedNode ||
              (selectedNode.type === "folder" && selectedNode.path === "")
            }
          >
            <Trash2 size={20} strokeWidth={2} />
          </button>
          <button
            className={`sidebar-toolbar-button icon-button${
              searchOpen ? " sidebar-toolbar-button-active" : ""
            }`}
            aria-label="Search entries"
            data-tooltip="Search entries"
            onClick={() => setSearchOpen((prev) => !prev)}
          >
            <Search size={20} strokeWidth={2} />
          </button>
        </div>

        {searchOpen && (
          <div className="app-sidebar-search">
            <input
              type="text"
              placeholder="Search entries..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
          </div>
        )}

        <div className="app-directory-tree">
          {treeLoading ? (
            <div className="app-entry-empty">
              <p>Loading TapestryΓÇª</p>
            </div>
          ) : treeError ? (
            <div className="app-entry-empty">
              <p>{treeError}</p>
            </div>
          ) : visibleTree.length === 0 ? (
            <div className="app-entry-empty">
              <p>No files found in this Tapestry.</p>
            </div>
          ) : (
            renderTapestryNodes(visibleTree)
          )}
        </div>
      </aside>

      {leftPane.visible && (
        <div
          className="app-resize-handle app-resize-handle-left"
          onMouseDown={() => setIsResizingLeft(true)}
          style={{ gridColumn: 2 }}
        />
      )}

      {/* CENTER: main content pane */}
      <main className="app-main">
        {/* Tools launcher - top right */}
        {!isToolPaneOpen && (
          <div className="app-tools-launcher">
            <button
              className="tool-icon-button icon-button"
              onClick={() => openTool("results")}
              aria-label="Results"
              data-tooltip="Results"
            >
              <ScrollText size={32} strokeWidth={2.5} />
            </button>
            <button
              className="tool-icon-button icon-button"
              onClick={() => openTool("dice")}
              aria-label="Dice"
              data-tooltip="Dice"
            >
              <Dices size={32} strokeWidth={2.5} />
            </button>
            <button
              className="tool-icon-button icon-button"
              onClick={() => openTool("tables")}
              aria-label="Tables"
              data-tooltip="Tables"
            >
              <LayoutPanelTop size={32} strokeWidth={2.5} />
            </button>
            <button
              className="tool-icon-button icon-button"
              onClick={() => openTool("diceDev")}
              aria-label="Dice dev"
              data-tooltip="Dice Dev"
            >
              <FlaskConical size={32} strokeWidth={2.5} />
            </button>
            {settings.developerMode && (
              <button
                className="tool-icon-button icon-button"
                onClick={() => openTool("devTools")}
                aria-label="Dev Tools"
                data-tooltip="Dev Tools"
              >
                <FlaskConical size={32} strokeWidth={2.5} />
              </button>
            )}
          </div>
        )}
        <div className="app-main-tabbar">
          {tabs.map((tab) => (
            <button
              key={tab.id}
              className={
                "app-main-tab" + (tab.id === activeTabId ? " app-main-tab--active" : "")
              }
              onClick={() => {
                setActiveTabId(tab.id);
                if (tab.kind === "tome") setActiveEntryId(tab.id);
              }}
              title={tab.title}
            >
              <span className="app-main-tab-title">{tab.title}</span>
              {tab.kind !== "home" && (
                <span
                  className="app-main-tab-close"
                  role="button"
                  aria-label={`Close ${tab.title}`}
                  onClick={(event) => {
                    event.stopPropagation();
                    closeTab(tab.id);
                  }}
                >
                  ├ù
                </span>
              )}
            </button>
          ))}
        </div>
        <div className="app-main-body">
          <div className="app-main-inner">
            {renderTabContent(tabs.find((t) => t.id === activeTabId))}
          </div>
        </div>
      </main>

      {/* RIGHT: tools pane */}
      {isToolPaneOpen && (
        <>
        <div
          className="app-resize-handle app-resize-handle-right"
          onMouseDown={() => setIsResizingRight(true)}
          style={{ gridColumn: 4 }}
        />
        <div className="app-tools-expanded">
          <div className="app-tools-header">
            <div className="app-tools-tabs">
              <button
                className={`tool-tab icon-button${
                  activeTool === "results" ? " tool-tab-active" : ""
                }`}
                onClick={() => setActiveTool("results")}
                aria-label="Results"
                data-tooltip="Results"
              >
                <ScrollText size={24} strokeWidth={2.5} />
              </button>
              <button
                className={`tool-tab icon-button${
                  activeTool === "dice" ? " tool-tab-active" : ""
                }`}
                onClick={() => setActiveTool("dice")}
                aria-label="Dice"
                data-tooltip="Dice"
              >
                <Dices size={24} strokeWidth={2.5} />
              </button>
              <button
                className={`tool-tab icon-button${
                  activeTool === "tables" ? " tool-tab-active" : ""
                }`}
                onClick={() => setActiveTool("tables")}
                aria-label="Tables"
                data-tooltip="Tables"
              >
                <LayoutPanelTop size={24} strokeWidth={2.5} />
              </button>
              <button
                className={`tool-tab icon-button${
                  activeTool === "diceDev" ? " tool-tab-active" : ""
                }`}
                onClick={() => setActiveTool("diceDev")}
                aria-label="Dice Dev"
                data-tooltip="Dice Dev"
              >
                <FlaskConical size={24} strokeWidth={2.5} />
              </button>
              {settings.developerMode && (
                <button
                  className={`tool-tab icon-button${
                    activeTool === "devTools" ? " tool-tab-active" : ""
                  }`}
                  onClick={() => setActiveTool("devTools")}
                  aria-label="Dev Tools"
                  data-tooltip="Dev Tools"
                >
                  <FlaskConical size={24} strokeWidth={2.5} />
                </button>
              )}
            </div>
            <button
              className="pane-collapse-button"
              onClick={toggleRightPane}
              aria-label="Collapse tools"
              title="Collapse tools"
              style={{ position: "absolute", top: "8px", right: "40px" }}
            >
              <PanelRightClose size={18} strokeWidth={2} />
            </button>
            <button
              className="app-tools-close"
              onClick={closeTools}
              title="Close tools"
            >
              ├ù
            </button>
          </div>

          <div className="app-tools-body">{renderToolContent()}</div>
        </div>
        </>
      )}
      </div>

      <footer className="app-status-bar">
        <div className="app-status-actions">
          <button
            className="status-icon-button icon-button"
            aria-label="Account"
            data-tooltip="Account"
          >
            <User size={24} strokeWidth={2} />
          </button>
          <button
            className={`status-icon-button icon-button${
              uiSettings.logToEntry ? " sidebar-icon-button--active" : ""
            }`}
            aria-label="Log to Entry"
            data-tooltip={uiSettings.logToEntry ? "Logging to Entry: ON" : "Logging to Entry: OFF"}
            onClick={() => setUiSettings(s => ({ ...s, logToEntry: !s.logToEntry }))}
          >
            <NotebookPen size={24} strokeWidth={2} />
          </button>
          <button
            className="status-icon-button icon-button"
            aria-label="Settings"
            data-tooltip="Settings"
            onClick={handleOpenSettings}
          >
            <Settings size={24} strokeWidth={2} />
          </button>
          <button
            className="status-icon-button icon-button"
            aria-label="Plugins"
            data-tooltip="Plugins"
          >
            <Puzzle size={24} strokeWidth={2} />
          </button>
          <button
            className="status-icon-button icon-button"
            aria-label="Toggle theme"
            data-tooltip={
              settings.theme === "dark"
                ? "Switch to light mode"
                : "Switch to dark mode"
            }
            onClick={toggleTheme}
          >
            <SunMoon size={24} strokeWidth={2} />
          </button>
        </div>
        <div className="app-status-indicator">
          <span>Status:</span> {statusText}
        </div>
      </footer>
      {isSettingsOpen && (
        <div
          className="settings-overlay"
          role="presentation"
          onClick={() => setSettingsOpen(false)}
        >
          <div
            className="settings-modal"
            role="dialog"
            aria-modal="true"
            aria-label="Anvil and Loom settings"
            onClick={(event) => event.stopPropagation()}
          >
            <div className="settings-modal-header">
              <div>
                <p className="settings-modal-eyebrow">Anvil & Loom</p>
                <h1>Settings</h1>
              </div>
              <button
                className="icon-button settings-close-button"
                aria-label="Close settings"
                onClick={() => setSettingsOpen(false)}
              >
                <X size={22} strokeWidth={2.5} />
              </button>
            </div>
            <div className="settings-modal-body">
              <aside className="settings-sidebar">
                <p className="settings-sidebar-label">Options</p>
                <div className="settings-nav">
                  {settingsNav.map((section) => (
                    <button
                      key={section.id}
                      className={
                        "settings-nav-button" +
                        (settingsCategory === section.id
                          ? " settings-nav-button-active"
                          : "")
                      }
                      onClick={() => setSettingsCategory(section.id)}
                    >
                      {section.label}
                    </button>
                  ))}
                </div>
              </aside>
              <div className="settings-content">{renderSettingsContent()}</div>
            </div>
          </div>
        </div>
      )}
      {modalState && (
        <div className="app-modal-overlay">
          <div className="app-modal" role="dialog" aria-modal="true">
            {modalState.type === "create" ? (
              <>
                <h3>
                  {modalState.target === "entry"
                    ? "Create New Entry"
                    : "Create New Folder"}
                </h3>
                <input
                  className="app-modal-input"
                  autoFocus
                  placeholder={
                    modalState.target === "entry"
                      ? "Entry name"
                      : "Folder name"
                  }
                  value={modalValue}
                  onChange={(event) => setModalValue(event.target.value)}
                  onKeyDown={(event) => {
                    if (event.key === "Enter") {
                      event.preventDefault();
                      handleModalConfirm();
                    }
                    if (event.key === "Escape") {
                      event.preventDefault();
                      closeModal();
                    }
                  }}
                />
                <div className="app-modal-actions">
                  <button onClick={closeModal}>Cancel</button>
                  <button
                    onClick={handleModalConfirm}
                    disabled={!modalValue.trim()}
                  >
                    Create
                  </button>
                </div>
              </>
            ) : (
              <>
                <h3>Delete {modalState.node.type === "file" ? "Entry" : "Folder"}</h3>
                <p>
                  Are you sure you want to delete{" "}
                  <strong>{modalState.node.name}</strong>? This cannot be
                  undone.
                </p>
                <div className="app-modal-actions">
                  <button onClick={closeModal}>Cancel</button>
                  <button onClick={handleModalConfirm} className="danger">
                    Delete
                  </button>
                </div>
              </>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

export default App;

function formatOracleCard(payload: {
  tableId: string;
  tableName: string;
  roll: number;
  resultText: string;
  tags: string[];
  sourcePath: string;
}): string {
  const header = `> ≡ƒº╡ Oracle ΓÇô ${payload.tableName} (${payload.roll})`;
  const body = payload.resultText ? `\n> ${payload.resultText}` : "";
  const meta = `\n<!-- forge:oracle tableId="${payload.tableId}" sourcePath="${payload.sourcePath}" roll=${payload.roll} result="${payload.resultText?.replace(/"/g, '\\"')}" tags="${JSON.stringify(payload.tags || []).replace(/"/g, '\\"')}" -->`;
  return `${header}${body}${meta}`;
}

function formatOracleHtmlCard(payload: {
  tableId: string;
  tableName: string;
  roll: number;
  resultText: string;
  tags: string[];
  sourcePath: string;
  category?: string;
}): string {
  // Mirrors the Dice Tool CHALLENGE ROLL HTML card used inside entries, but for table rolls
  const id = `dice-log-${Date.now()}-${Math.floor(Math.random() * 100000)}`;
  const categoryLabel = payload.category === "Aspect" ? "ASPECT" : payload.category === "Domain" ? "DOMAIN" : "ORACLE";
  const title = `${categoryLabel}: ${payload.tableName.toUpperCase()}`;
  const body = payload.resultText || "";
  const meta = `<!-- forge:oracle tableId="${payload.tableId}" sourcePath="${payload.sourcePath}" roll=${payload.roll} result="${payload.resultText?.replace(/"/g, '\\"')}" tags='${JSON.stringify(payload.tags || [])}' category="${payload.category || ""}" -->`;
  const html = `<div class="dice-card dice-card-inline dice-log-card"><input type="checkbox" id="${id}" class="dice-log-toggle" /><label for="${id}" class="dice-card-title dice-log-header"><span>${title}</span><span class="dice-log-caret" aria-hidden="true"></span></label><div class="dice-card-body dice-log-body"><div class="dice-card-detail"><span>ROLL RESULT:</span> <strong>${payload.roll}</strong></div></div><div class="dice-card-highlight dice-log-footer"><span class="dice-log-footer-label">Result:</span><span class="dice-card-inline-result">${escapeHtml(body)}</span></div></div>${meta}`;
  return html;
}

function escapeHtml(text: string) {
  if (!text) return "";
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

  const renderDiceDevHighlights = (result: RollResult) => {
    const highlights = annotateRollResult(result);
    if (!highlights.length) return null;
    return (
      <div className="dice-dev-highlights">
        {highlights.map((highlight, index) => (
          <DiceDevHighlight key={`${highlight.type}-${index}`} highlight={highlight} />
        ))}
      </div>
    );
  };
const DiceDevHighlight = ({ highlight }: { highlight: RollHighlight }) => {
  switch (highlight.type) {
    case "challenge-outcome":
      return (
        <div
          className="dice-dev-highlight challenge"
          style={{ borderColor: highlight.color }}
        >
          <strong style={{ color: highlight.color }}>{highlight.outcome}</strong>
          {highlight.boon && <span> ΓÇó Boon</span>}
          {highlight.complication && <span> ΓÇó Complication</span>}
        </div>
      );
    case "natural-crit":
      return (
        <div className="dice-dev-highlight crit">
          {highlight.crit === "success" ? "Natural 20!" : "Natural 1!"} (die #{highlight.dieIndex + 1})
        </div>
      );
    case "pool-success":
      return (
        <div className="dice-dev-highlight pool">
          {highlight.successes} success
          {highlight.successes === 1 ? "" : "es"}
          {typeof highlight.target === "number" && (
            <>
              {" "}
              / target {highlight.target}{" "}
              {highlight.metTarget ? "(met)" : "(not met)"}
            </>
          )}
        </div>
      );
    case "degrade":
      return (
        <div className="dice-dev-highlight degrade">
          Die steps down by {highlight.step}
          {highlight.step === 1 ? "" : " steps"}
        </div>
      );
    default:
      return null;
  }
};
